diff --git a/src/experiments/run_experiment.py b/src/experiments/run_experiment.py
--- a/src/experiments/run_experiment.py
+++ b/src/experiments/run_experiment.py
@@ -1,20 +1,95 @@
-import argparse, json, time, os
-from ca_alns.solver import solve
+import argparse, json, time, os
+from ca_alns.solver import solve
+from ca_alns.local_search import two_opt, or_opt
 
 parser = argparse.ArgumentParser()
-parser.add_argument("--algo", required=True, choices=["ca-alns","ga","de"])
+parser.add_argument("--algo", required=True, choices=["ca-alns","alns-std","alns-ls","ga","de"])
 parser.add_argument("--seed", type=int, default=0)
 parser.add_argument("--E_max", type=int, default=100000)
 parser.add_argument("--T_max", type=int, default=600)
 parser.add_argument("--rho", type=float, default=0.1)
 parser.add_argument("--vmax", type=float, default=15.0)
 parser.add_argument("--out", required=True)
+parser.add_argument("--n_uav", type=int, default=5)
+parser.add_argument("--n_targets", type=int, default=20)
+
+def algo_to_flags(algo):
+    # connectivity handling, rally, local search
+    if algo == "ca-alns":
+        return dict(connectivity="safety", rally=True, do_ls=False)
+    if algo == "alns-std":
+        return dict(connectivity="penalty", rally=False, do_ls=False)
+    if algo == "alns-ls":
+        return dict(connectivity="penalty", rally=False, do_ls=True)
+    # GA/DE handled elsewhere
+    return dict(connectivity="penalty", rally=False, do_ls=False)
 
 def main():
     args = parser.parse_args()
-    inst = gen_random_instance(seed=args.seed)
-    res = solve(inst, algo=args.algo, E_max=args.E_max, T_max=args.T_max,
-                rho=args.rho, v_max=args.vmax)
+    inst = gen_random_instance(seed=args.seed, n_uav=args.n_uav, n_targets=args.n_targets)
+    flags = algo_to_flags(args.algo)
+
+    res = solve(inst,
+                algo=args.algo,
+                E_max=args.E_max,
+                T_max=args.T_max,
+                rho=args.rho,
+                v_max=args.vmax,
+                connectivity_mode=flags["connectivity"],
+                rally_enabled=flags["rally"])
+
+    # local search add-on for ALNS+LS
+    if flags.get("do_ls") and "routes" in res:
+        routes = res["routes"]
+        improved = True
+        while improved:
+            improved, routes = two_opt(routes)
+            improved2, routes = or_opt(routes, k_max=3)
+            improved = improved or improved2
+        res["routes"] = routes
+        # recompute metrics if util available
+        if "recompute" in res:
+            res.update(res["recompute"](routes))
+
     with open(args.out, "w") as f:
         json.dump(res, f, indent=2)
 
 if __name__ == "__main__":
     main()
diff --git a/src/ca_alns/local_search.py b/src/ca_alns/local_search.py
new file mode 100644
--- /dev/null
+++ b/src/ca_alns/local_search.py
@@ -0,0 +1,68 @@
+from typing import List, Tuple
+
+def route_cost(route):
+    # expects route as list of node ids with depot at both ends
+    # placeholder: replace with your distance matrix lookup
+    return 0.0
+
+def two_opt(routes: List[List[int]]) -> Tuple[bool, List[List[int]]]:
+    improved = False
+    new_routes = []
+    for r in routes:
+        best = r[:]
+        best_cost = route_cost(best)
+        n = len(r)
+        for i in range(1, n-2):
+            for k in range(i+1, n-1):
+                cand = r[:i] + list(reversed(r[i:k])) + r[k:]
+                c = route_cost(cand)
+                if c < best_cost:
+                    best, best_cost = cand, c
+                    improved = True
+        new_routes.append(best)
+    return improved, new_routes
+
+def or_opt(routes: List[List[int]], k_max=3) -> Tuple[bool, List[List[int]]]:
+    improved = False
+    new_routes = []
+    for r in routes:
+        best = r[:]
+        best_cost = route_cost(best)
+        n = len(r)
+        for k in range(1, k_max+1):
+            for i in range(1, n-k-1):
+                seg = r[i:i+k]
+                remain = r[:i] + r[i+k:]
+                for j in range(1, len(remain)):
+                    cand = remain[:j] + seg + remain[j:]
+                    c = route_cost(cand)
+                    if c < best_cost:
+                        best, best_cost = cand, c
+                        improved = True
+        new_routes.append(best)
+    return improved, new_routes
